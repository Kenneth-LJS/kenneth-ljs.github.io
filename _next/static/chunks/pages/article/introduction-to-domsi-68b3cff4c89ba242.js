(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[143],{34264:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/article/introduction-to-domsi",function(){return n(76859)}])},8353:function(e,t,n){"use strict";var r=n(85893),o=n(57779),a=n(55829),i=n(99840),s=n(18532),l=n(98683),c=n(84283),h=n(45146),d=n(53222),m=n.n(d),p=n(15252);let u=c.Ro,g=m().codeBgColor,y=c.Ro['code[class*="language-"]'].fontFamily,w={...u,':not(pre) > code[class*="language-"]':{...u[':not(pre) > code[class*="language-"]'],background:g},'code[class*="language-"]':{...u['code[class*="language-"]'],background:g},'pre[class*="language-"]':{...u['pre[class*="language-"]'],background:g}},f=e=>{let{siteHeadProps:t,articleMarkdown:n}=e;return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.Z,{...t}),(0,r.jsx)(o.Z,{footerContent:"Designed and built from scratch by ".concat(p.Rh," with NextJS and SCSS!"),children:(0,r.jsx)(a.Z,{children:(0,r.jsx)("div",{className:m().article,style:{"--code-font-family":y},children:(0,r.jsx)(s.D,{rehypePlugins:[h.Z],components:{code(e){let{node:t,inline:n,className:o,children:a,...i}=e,s=/language-(\w+)/.exec(o||"");return!n&&s?(0,r.jsx)(l.Z,{style:w,language:s[1],PreTag:"div",...i,children:String(a).replace(/\n$/,"")}):(0,r.jsx)("code",{className:o,...i,children:a})}},children:n})})})})]})};t.Z=f},55731:function(e,t,n){"use strict";n.d(t,{w:function(){return a}});var r=n(15252);function o(e){return new URL(e,r.Tu).toString()}let a={INTRODUCTION_TO_DOMSI:{title:"Introduction to Domsi",href:"/article/introduction-to-domsi/",sitePreview:{img:{src:o("/article/introduction-to-domsi/thumbnail.png"),type:"image/png",width:600,height:400},description:"A powerful and blazingly fast web scraping library that integrates element styles, attributes, and DOM hierarchy in its selectors."},card:{title:"Domsi",description:"A powerful and blazingly fast web scraping library that integrates element styles, attributes, and DOM hierarchy in its selectors.",thumbnailSrc:"/article/introduction-to-domsi/thumbnail.webp",tags:["Web scraping","Typescript","Open Source","Algorithm"]}},MURDER_MYSTERY_GAME:{title:"Murder Mystery Game",href:"/article/murder-mystery-game/",sitePreview:{img:{src:o("/article/murder-mystery-game/thumbnail.png"),type:"image/png",width:600,height:400},description:"The game engine for a Victorian Murder Mystery game I designed for an online event."},card:{title:"Murder Mystery Game",thumbnailSrc:"/article/murder-mystery-game/thumbnail.webp",description:"I created a game engine for a Murder Mystery event! Learn how I used encryption concepts to obfuscate game data from prying players.",tags:["Game Engine","React","SCSS","Typescript","Cryptography","Webpack Loader"]}},FOCUS_SHEPHERD:{title:"Focus Shepherd",href:"/article/focus-shepherd/",sitePreview:{description:"Focus Shepherd is a TamperMonkey / GreaseMonkey script that gently reminds you to focus when you get distracted on your web browser!",img:{src:o("/article/focus-shepherd/thumbnail.png"),type:"image/png",width:600,height:400}},card:{title:"Focus Shepherd",thumbnailSrc:"/article/focus-shepherd/thumbnail.webp",description:"Focus Shepherd is a TamperMonkey / GreaseMonkey script that gently reminds you to focus when you get distracted on your web browser!",tags:["TamperMonkey / GreaseMonkey","HTML","Javascript","Productivity"]}},EXPLORING_EPICYCLES:{title:"Exploring Epicycles",href:"/article/exploring-epicycles/",sitePreview:{description:"Come with me on the journey to explore the Fourier transform, and how we can use that to compute epicycles.",img:{src:o("/article/exploring-epicycles/thumbnail.png"),type:"image/png",width:600,height:400}},card:{title:"Epicycles",thumbnailSrc:"/article/exploring-epicycles/thumbnail.webp",description:"Image processing with the Fast Fourier Transform to create an animated illustration of epicycles.",tags:["Python","Mathematics","Numpy","Python Imaging Library (PILLOW)","FFMPEG"]}},SNAP_CONSOLE:{title:"Snap Console",href:"/article/snap-console/",sitePreview:{img:{src:o("/article/snap-console/thumbnail.png"),type:"image/png",width:600,height:400},description:"A easy-to-use console library in Python to display beautiful outputs."},card:{title:"Snap Console",thumbnailSrc:"/article/snap-console/thumbnail.webp",description:"A easy-to-use console library in Python to display beautiful outputs. Implemented with the curses library.",tags:["Open Source","Python","Curses Terminal Library"]}},SHARD_GAME_ENGINE:{title:"Shard Game Engine",href:"/article/shard-game-engine/",sitePreview:{img:{src:o("/article/shard-game-engine/thumbnail.png"),type:"image/png",width:600,height:400},description:"A text-based game engine with a unique story structure. The engine allows users to create custom stories too."},card:{title:"Shard Game Engine",thumbnailSrc:"/article/shard-game-engine/thumbnail.webp",description:"A text-based game engine with a unique story structure. The engine allows users to create custom stories too.",tags:["Game Engine","SCSS","Typescript","Parcel.js"]}}}},76859:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return s}});var r=n(85893),o=n(8353),a=n(55731);let i=a.w.INTRODUCTION_TO_DOMSI;function s(){var e;return(0,r.jsx)(o.Z,{siteHeadProps:{title:i.title,description:i.sitePreview.description,image:i.sitePreview.img,twitterImageSrc:null===(e=i.sitePreview.img)||void 0===e?void 0:e.src},articleMarkdown:"<header>\n<h1>Introduction to Domsi</h1>\n\n<p>\n  Unleash the true potential of web-scraping through Domsi, a web scraping library that exploits DOM hierarchy.\n</p>\n\n<p>\n  <a href=\"#\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub</a> | <a href=\"#\" target=\"_blank\" rel=\"noopener noreferrer\">Demo</a>\n</p>\n\n</header>\n\n## Scraping with Domsi\n\nWeb scraping is hard! It’s been a long time since we’ve had websites with simple CSS classes like `.header` and `.username` that we could query and scrape. These days, we have to deal with pesky utility classes and compiled CSS modules that obfuscate the fields we are looking for. Even if we find some way to scrape website data based on these CSS class names, these queries are bound to break on the next build when the CSS class names change again.\n\nTo get a feel of this problem, let’s try scraping the social media posts of this mock website I put together: <a href=\"./static/kiwi-chirp/\" target=\"_blank\" rel=\"noopener noreferrer\">Kiwi Chirp</a>. Can you write a selector in order to scrape all the social media posts on this page? Your aim is to get the content of all 7 posts, along with their respective poster’s name and user ID. Go on, give it a go!\n\n<p align=center>\n  <img src=\"./static/website.png\" style=\"width: min(100%, 600px)\"><br/>\n  <em>Your adversary for today: the Kiwi Chirp website.</em>\n</p>\n\nIf you’ve made an attempt, you’ll find that the task is non-trivial. Attempting to scrape anything by attributes, styles, or roles alone is difficult, since there are many overlapping properties. For instance, trying to query the user ID (i.e. elements that start with “@”) will give us the elements in the posts, but also those in the “Recommended” bar. That’s not ideal, but let’s use this as a starting point.\n\nLet’s query all the elements that start with an “@”. Open the developer console on the Kiwi Chirp page and run the following command:\n\n```javascript\nArray.from(document.querySelectorAll('*')).filter((elem) =>\n    elem.textContent.startsWith('@')\n);\n```\n\nIt seems like we’re getting all the elements we want, but we’re also getting a few extra elements. Ugh.\n\nAnother option is to exploit the `dir=\"auto\"` property that’s found on the post content.\n\n```javascript\ndocument.querySelectorAll('*[dir=\"auto\"]');\n```\n\nThat’s pretty close too, but we get some stray elements too. Nothing short of a hacky method will solve this issue.\n\nThe frustrating thing is, websites are so easy for users to read. There’s a nice hierarchy of elements that lead our eyes through the webpage and communicate the structure of the information. Can we somehow take advantage of that in a way that doesn’t require horrible parent-child element traversals?\n\nMeet Domsi. “Dom” as in “Document Object Model”, and “Si” as in “See”. The goal of this library is to query elements by what we can see: CSS styles, text content, and hierarchy. To show you how easy it is to do this, let’s start with a simple Domsi selector.\n\n```javascript\n{ tagName: 'a' }\n```\n\nNothing impressive, we’re just finding all the anchor elements on the page. But let’s give it a go anyway. Head over to the Kiwi page. Domsi should already be loaded globally, so you can go ahead and use it with `domsi.find` or `domsi.findAll`. Let’s run the following code in the console:\n\n```javascript\ndomsi.findAll({ tagName: 'a' });\n```\n\nLet’s take a look at the results. We have 26 elements in the result, and each one takes the following shape:\n\n```javascript\n{\n    node: <HTML Element>,\n    children: {}\n}\n```\n\nIf you check each node in the DOM, you’ll find the respective element for each result. Alright, we’ve gotten all the anchor elements. But what if we also want to filter it by the text content like we did earlier? That’s easy, all we have to do is to add an additional `text` filter that filters out element text content with a Regex.\n\n```javascript\ndomsi.findAll({\n    tagName: 'a',\n    text: {\n        type: 'regex',\n        regex: '^@',\n    },\n});\n```\n\nIn fact, while we’re here, let’s make the selector more specific by filtering out the elements with a specific font size, weight, and color.\n\n```javascript\ndomsi.findAll({\n    tagName: 'a',\n    text: {\n        type: 'regex',\n        regex: '^@',\n    },\n    css: {\n        fontSize: '16px',\n        fontWeight: '400',\n        color: '#AAAAAA',\n    },\n});\n```\n\nThere’s also an `attribute` and `property` field that allows us to query elements by their attributes and properties respectively, but I won’t go into it here. After all, what we have here is pretty powerful, and gives us a good way to query specific elements on the page. But we’re still not at the point where we can scrape all the posts on this page. So what’s next?\n\nLet’s take advantage of Domsi’s children selector. Let’s take our earlier selector and assign it to a `userIdSelector` variable.\n\n```javascript\nvar userIdSelector = {\n    tagName: 'a',\n    text: {\n        type: 'regex',\n        regex: '^@',\n    },\n    css: {\n        fontSize: '16px',\n        fontWeight: '400',\n        color: '#AAAAAA',\n    },\n};\n```\n\nLet’s also add a `usernameSelector` too. This selector looks out for the usernames on the social media posts.\n\n```javascript\nvar usernameSelector = {\n    tagName: 'a',\n    css: {\n        fontSize: '16px',\n        fontWeight: '700',\n        color: '#EEEEEE',\n    },\n};\n```\n\nNow for the fun part. Run the following query:\n\n```javascript\nvar userInfoSelector = {\n    children: {\n        username: {\n            type: 'single',\n            selector: usernameSelector,\n        },\n        userId: {\n            type: 'single',\n            selector: userIdSelector,\n        },\n    },\n};\n\ndomsi.findAll(userInfoSelector);\n```\n\nWe’re trying to query the div in the post that contains both the username and the user ID. The `children` property allows us to specify a `username` and a `userId` child. The type is `single` since we’re only expecting 1 element of each, and the selector simply references the earlier selector.\n\nLooking at the results, we’re really close now. We’ve found the header element of each post, allowing us to scrape the data easily. However, we’re still getting the additional elements in the “Recommended” bar.\n\nFret not! We realize that the text in the sidebar includes a newline in the text content, since the username and the user ID takes up 2 rows. We can simply use the Regex selector from earlier, except now we invert the value with a `not` selector.\n\n```javascript\nvar userInfoSelector = {\n    text: {\n        type: 'not',\n        operand: {\n            type: 'regex',\n            regex: '\\n',\n        },\n    },\n    children: {\n        username: {\n            type: 'single',\n            selector: usernameSelector,\n        },\n        userId: {\n            type: 'single',\n            selector: userIdSelector,\n        },\n    },\n};\n\ndomsi.findAll(userInfoSelector);\n```\n\nAnd there! We’ve created a selector which finds the exact elements we’re looking to scrape. With a bit more effort, we can put together a more complex selector.\n\n```javascript\nvar profileImgSelector = {\n    tagName: 'img',\n    css: {\n        width: '50px',\n        height: '50px',\n    },\n};\n\nvar usernameSelector = {\n    tagName: 'a',\n    css: {\n        fontSize: '16px',\n        fontWeight: '700',\n        color: '#EEEEEE',\n    },\n};\n\nvar userIdSelector = {\n    tagName: 'a',\n    text: {\n        type: 'regex',\n        regex: '^@',\n    },\n    css: {\n        fontSize: '16px',\n        fontWeight: '400',\n        color: '#AAAAAA',\n    },\n};\n\nvar timestampSelector = {\n    tagName: 'span',\n};\n\nvar postHeaderSelector = {\n    tagName: 'div',\n    children: {\n        username: {\n            type: 'single',\n            selector: usernameSelector,\n        },\n        userId: {\n            type: 'single',\n            selector: userIdSelector,\n        },\n        timestamp: {\n            type: 'single',\n            selector: timestampSelector,\n        },\n    },\n};\n\nvar contentSelector = {\n    attribute: {\n        dir: 'auto',\n    },\n};\n\nvar likeCountSelector = {\n    tagName: 'span',\n};\n\nvar likeIconSelector = {\n    attribute: {\n        'aria-label': 'Like',\n    },\n};\n\nvar likeContainerSelector = {\n    children: {\n        likeCount: {\n            type: 'single',\n            selector: likeCountSelector,\n        },\n        likeIcon: {\n            type: 'single',\n            selector: likeIconSelector,\n        },\n    },\n};\n\nvar commentCountSelector = {\n    tagName: 'span',\n};\n\nvar commentIconSelector = {\n    attribute: {\n        'aria-label': 'Comment',\n    },\n};\n\nvar commentContainerSelector = {\n    children: {\n        commentCount: {\n            type: 'single',\n            selector: commentCountSelector,\n        },\n        commentIcon: {\n            type: 'single',\n            selector: commentIconSelector,\n        },\n    },\n};\n\nvar postFooterSelector = {\n    tagName: 'div',\n    children: {\n        likeContainer: {\n            type: 'single',\n            transparent: true,\n            selector: likeContainerSelector,\n        },\n        commentContainer: {\n            type: 'single',\n            transparent: true,\n            selector: commentContainerSelector,\n        },\n    },\n};\n\nvar postSelector = {\n    tagName: 'div',\n    children: {\n        profileImg: {\n            type: 'single',\n            selector: profileImgSelector,\n        },\n        postHeader: {\n            type: 'single',\n            transparent: true,\n            selector: postHeaderSelector,\n        },\n        postFooter: {\n            type: 'single',\n            transparent: true,\n            selector: postFooterSelector,\n        },\n        content: {\n            type: 'single',\n            selector: contentSelector,\n        },\n    },\n};\n\nvar results = domsi.findAll(postSelector);\nresults;\n```\n\nAnd there you go, all the respective elements are queried. Let’s check out the results this time.\n\n```javascript\n{\n    node: <HTML Element>,\n    children: {\n        username: { node: <HTML Element>, children: {} },\n        userId: { node: <HTML Element>, children: {} },\n        content: { node: <HTML Element>, children: {} },\n        timestamp: { node: <HTML Element>, children: {} },\n        profileImg: { node: <HTML Element>, children: {} },\n        content: { node: <HTML Element>, children: {} },\n        likeCount: { node: <HTML Element>, children: {} },\n        commentCount: { node: <HTML Element>, children: {} },\n        ...\n    }\n}\n```\n\nNotice how the fields under the `children` property matches the names we gave the child selectors? We can use that to look up the respective elements. Now, we can simply look up the property of each child element to scrape the data.\n\n```javascript\nvar data = results.map((result) => {\n    const {\n        profileImg,\n        username,\n        userId,\n        timestamp,\n        likeCount,\n        commentCount,\n        content,\n    } = result.children;\n\n    return {\n        profileImg: profileImg.node.src,\n        username: username.node.textContent,\n        userId: userId.node.textContent,\n        timestamp: timestamp.node.textContent,\n        profileUrl: userId.node.href,\n        likeCount: parseInt(likeCount.node.textContent),\n        commentCount: parseInt(commentCount.node.textContent),\n        content: content.node.innerText,\n    };\n});\ndata;\n```\n\nAnd that’s it, we’re done! To recap, we’ve taken a non-trivial problem and reduced it to a bunch of easy-to-understand queries.\n\n## The Power of Domsi\n\nLet’s see how this is better than conventional web scraping methods.\n\nFirstly, Domsi selectors have a powerful hierarchy structure built into them. The nested queries allow for complex HTML structures to be easily found without having to rely on Javascript-based filters which may be buggy.\n\nSecondly, Domsi selectors don't need to rely on CSS classes which may change with each build. Instead, it relies on properties and attributes that aren’t likely to change. Properties such as font sizes and border colors largely remain the same as long as the website doesn’t mess around with their themes and layouts.\n\nThirdly, Domsi selectors do not rely on parent/child node navigation. If the website decides to add additional container divs in between each level, the selector would still work. No more fiddling with finicky nested `.parentElement.parentElement.parentElement` ad infinitum.\n\nFourthly, the query is self-documenting. Unlike horribly nested parent/child traversals and arbitrary property checks, Domsi queries allow you to label each node with an easy-to-understand selector. This makes development and maintenance much easier. No more tweaking xpaths and selectors! No more throwing out old scraping codes because the monolith of a function no longer works!\n\nAnd that’s not all! There are a lot more subtle features such as the `and` and `or` selectors. Also, when comparing colors, the color selector converts hex values and rgb values under the hood, saving yourself the unnecessary conversion headache. Check out the documentation for more info!\n\n## But How Fast Is It?\n\nVery good question. What if you want to scrape a huge web page with tons of data? If Domsi uses an inefficient method to compute the hierarchy of selectors, then we’re going to end up with a very long runtime.\n\nFortunately, Domsi uses a blazingly fast algorithm under the hood. The runtime of the query is:\n\n<p align=center>\n  <code style=\"font-size: 3em\">O(nmk)</code>\n</p>\n\nWhere:\n\n-   `n` = number of DOM nodes\n-   `m` = number of children selectors\n-   `k` = max height of DOM tree\n\n“But wait”, you may ask, “Is it even possible to do it this quickly? After all, the algorithm needs to do a recursive search to check if an element’s children match the selector’s hierarchy.”\n\nAhah, that’s the genius of it. Let’s walk you through the algorithm. Consider the following nested selector. The red selector contains 2 children: the green and blue selector. The green selector contains 1 child: the yellow selector.\n\nEach of the 4 selectors also have their own fields to filter HTML nodes by their various properties.\n\n<p align=center>\n  <img src=\"./static/query.png\" style=\"width: min(100%, 250px)\">\n</p>\n\nFirst, we do a topological sort of the selector’s children. For instance, given the following selector, we will start with the yellow, green, blue, then red selector.\n\nNow let’s take a look at how the selector is used to query the HTML DOM.\n\n<p align=center>\n  <img src=\"./static/algorithm-step-0.png\" style=\"width: min(100%, 800px)\">\n</p>\n\nWe start with the yellow selector, since that is the first selector in our topological sort. We see that it matches the following `span` elements in the DOM tree.\n\n<p align=center>\n  <img src=\"./static/algorithm-step-1A.png\" style=\"width: min(100%, 800px)\">\n</p>\n\nFor each element that matches the selector, we step through its parents and mark them as containing the yellow selector, as indicated by the yellow check mark.\n\n<p align=center>\n  <img src=\"./static/algorithm-step-1B.png\" style=\"width: min(100%, 800px)\">\n</p>\n\nNext, we move on to the green selector. In this case, the 2 indicated `div`s match the attribute, property, style, text, etc selectors.\n\n<p align=center>\n  <img src=\"./static/algorithm-step-2A.png\" style=\"width: min(100%, 800px)\">\n</p>\n\nHowever, we note that only the bottom `div` node contains the yellow element required, so we mark it as green and ignore the other one. Notice that since the green HTML node already has the yellow child marked, this check runs in O(1) time, reducing the need for a computationally-expensive tree search.\n\n<p align=center>\n  <img src=\"./static/algorithm-step-2B.png\" style=\"width: min(100%, 800px)\">\n</p>\n\nAgain, we mark its parents with the green check mark.\n\n<p align=center>\n  <img src=\"./static/algorithm-step-2C.png\" style=\"width: min(100%, 800px)\">\n</p>\n\nWe repeat this check for the blue selector.\n\n<p align=center>\n  <img src=\"./static/algorithm-step-3A.png\" style=\"width: min(100%, 800px)\">\n</p>\n\nAnd then we mark their parents.\n\n<p align=center>\n  <img src=\"./static/algorithm-step-3B.png\" style=\"width: min(100%, 800px)\">\n</p>\n\nNow on to the red selector.\n\n<p align=center>\n  <img src=\"./static/algorithm-step-4A.png\" style=\"width: min(100%, 800px)\">\n</p>\n\nAgain, notice that even though 2 HTML nodes contain the same styles in the red selector, only the second HTML node has the required green and blue children. We then mark it as a red node, and indicate this on its parents.\n\n<p align=center>\n  <img src=\"./static/algorithm-step-4C.png\" style=\"width: min(100%, 800px)\">\n</p>\n\nAgain, since the existence of the green and blue HTML children are already marked, this check happens in `O(1)` time. Now, we can return the single red HTML node that was found.\n\n<p align=center>\n  <img src=\"./static/algorithm-step-5B.png\" style=\"width: min(100%, 800px)\">\n</p>\n\nLet’s compute the runtime.\n\nFor each node, let’s assume it takes `O(1)` time to check if the styles and properties match a selector.\n\nThe topological sort takes `O(m)` time.\n\nAfter that, for each of the `m` selectors, we compare it with `n` different elements in the node for `O(nm)` time. Unfortunately, we have to traverse upwards through the DOM tree to mark the existence of a specific child, so that’s an `O(k)` time for each step.\n\nThat brings the overall runtime to `O(m) + O(nmk) = O(nmk)`. Unbelievably fast for the functionality of this complexity.\n\n## Future Plans\n\nWell, for one, Domsi could use a bit of refinement. There are a bunch of edge cases such as how the `border-color` property translates into `border-top-color`, `border-bottom-color`, `border-left-color`, and `border-right-color`.\n\nI also want to add additional conditional queries such as value-checking, element size, and comparison of element position between children.\n\nThere’s also a tiny bug in the algorithm where the two children of a selector may actually be contained in one, but that’s a really rare edge case.\n\nEither way, there’s still some work to be done. But for now, the Domsi library is already powerful enough for most web scraping needs.\n\nYou can check out the <a href=\"https://github.com/Kenneth-LJS/domsi\" target=\"_blank\" rel=\"noopener noreferrer\">Domsi Github Page</a>, or install it from the <a href=\"https://www.npmjs.com/package/domsi\" target=\"_blank\" rel=\"noopener noreferrer\">Node Package Manager</a>.\n\nHappy scraping!\n"})}},53222:function(e){e.exports={baseFs:"18px",baseColor:"#1f2834",primaryColor:"#eee",secondaryColor:"#11d0da",codeBgColor:"#12171e",article:"page_article__eRMb9"}}},function(e){e.O(0,[108,187,646,774,888,179],function(){return e(e.s=34264)}),_N_E=e.O()}]);