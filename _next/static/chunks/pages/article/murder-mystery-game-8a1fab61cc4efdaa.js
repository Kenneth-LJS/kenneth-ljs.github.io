(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[399],{67635:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/article/murder-mystery-game",function(){return n(62958)}])},8353:function(e,t,n){"use strict";var a=n(85893),r=n(34914),i=n(55829),o=n(99840),s=n(18532),c=n(98683),l=n(84283),h=n(45146),p=n(53222),d=n.n(p),u=n(15252);let g=l.Ro,y=d().codeBgColor,m=l.Ro['code[class*="language-"]'].fontFamily,w={...g,':not(pre) > code[class*="language-"]':{...g[':not(pre) > code[class*="language-"]'],background:y},'code[class*="language-"]':{...g['code[class*="language-"]'],background:y},'pre[class*="language-"]':{...g['pre[class*="language-"]'],background:y}},f=e=>{let{siteHeadProps:t,articleMarkdown:n}=e;return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(o.Z,{...t}),(0,a.jsx)(r.Z,{footerContent:"Designed and built from scratch by ".concat(u.Rh," with NextJS and SCSS!"),children:(0,a.jsx)(i.Z,{children:(0,a.jsx)("div",{className:d().article,style:{"--code-font-family":m},children:(0,a.jsx)(s.D,{rehypePlugins:[h.Z],components:{code(e){let{node:t,inline:n,className:r,children:i,...o}=e,s=/language-(\w+)/.exec(r||"");return!n&&s?(0,a.jsx)(c.Z,{style:w,language:s[1],PreTag:"div",...o,children:String(i).replace(/\n$/,"")}):(0,a.jsx)("code",{className:r,...o,children:i})}},children:n})})})})]})};t.Z=f},55731:function(e,t,n){"use strict";n.d(t,{w:function(){return i}});var a=n(15252);function r(e){return new URL(e,a.Tu).toString()}let i={INTRODUCTION_TO_DOMSI:{title:"Introduction to Domsi",href:"/article/introduction-to-domsi/",sitePreview:{img:{src:r("/article/introduction-to-domsi/thumbnail.png"),type:"image/png",width:600,height:400},description:"A powerful and blazingly fast web scraping library that integrates element styles, attributes, and DOM hierarchy in its selectors."},card:{title:"Domsi",description:"A powerful and blazingly fast web scraping library that integrates element styles, attributes, and DOM hierarchy in its selectors.",thumbnailSrc:"/article/introduction-to-domsi/thumbnail.webp",tags:["Web scraping","Typescript","NPM","Open Source","Algorithm"]}},MURDER_MYSTERY_GAME:{title:"Murder Mystery Game",href:"/article/murder-mystery-game/",sitePreview:{img:{src:r("/article/murder-mystery-game/thumbnail.png"),type:"image/png",width:600,height:400},description:"The game engine for a Victorian Murder Mystery game I designed for an online event."},card:{title:"Murder Mystery Game",thumbnailSrc:"/article/murder-mystery-game/thumbnail.webp",description:"I created a game engine for a Murder Mystery event! Learn how I used encryption concepts to obfuscate game data from prying players.",tags:["Game Engine","React","SCSS","Typescript","Cryptography","Webpack Loader"]}},FOCUS_SHEPHERD:{title:"Focus Shepherd",href:"/article/focus-shepherd/",sitePreview:{description:"Focus Shepherd is a TamperMonkey / GreaseMonkey script that gently reminds you to focus when you get distracted on your web browser!",img:{src:r("/article/focus-shepherd/thumbnail.png"),type:"image/png",width:600,height:400}},card:{title:"Focus Shepherd",thumbnailSrc:"/article/focus-shepherd/thumbnail.webp",description:"Focus Shepherd is a TamperMonkey / GreaseMonkey script that gently reminds you to focus when you get distracted on your web browser!",tags:["TamperMonkey / GreaseMonkey","HTML","Javascript","Productivity"]}},EXPLORING_EPICYCLES:{title:"Exploring Epicycles",href:"/article/exploring-epicycles/",sitePreview:{description:"Come with me on the journey to explore the Fourier transform, and how we can use that to compute epicycles.",img:{src:r("/article/exploring-epicycles/thumbnail.png"),type:"image/png",width:600,height:400}},card:{title:"Epicycles",thumbnailSrc:"/article/exploring-epicycles/thumbnail.webp",description:"Image processing with the Fast Fourier Transform to create an animated illustration of epicycles.",tags:["Python","Mathematics","Numpy","Python Imaging Library (PILLOW)","FFMPEG"]}},SNAP_CONSOLE:{title:"Snap Console",href:"/article/snap-console/",sitePreview:{img:{src:r("/article/snap-console/thumbnail.png"),type:"image/png",width:600,height:400},description:"A easy-to-use console library in Python to display beautiful outputs."},card:{title:"Snap Console",thumbnailSrc:"/article/snap-console/thumbnail.webp",description:"A easy-to-use console library in Python to display beautiful outputs. Implemented with the curses library.",tags:["Python","Open Source","PIP","Curses Terminal Library"]}},SHARD_GAME_ENGINE:{title:"Shard Game Engine",href:"/article/shard-game-engine/",sitePreview:{img:{src:r("/article/shard-game-engine/thumbnail.png"),type:"image/png",width:600,height:400},description:"A text-based game engine with a unique story structure. The engine allows users to create custom stories too."},card:{title:"Shard Game Engine",thumbnailSrc:"/article/shard-game-engine/thumbnail.webp",description:"A text-based game engine with a unique story structure. The engine allows users to create custom stories too.",tags:["Game Engine","SCSS","Typescript","Parcel.js"]}}}},62958:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return s}});var a=n(85893),r=n(8353),i=n(55731);let o=i.w.MURDER_MYSTERY_GAME;function s(){var e;return(0,a.jsx)(r.Z,{siteHeadProps:{title:o.title,description:o.sitePreview.description,image:o.sitePreview.img,twitterImageSrc:null===(e=o.sitePreview.img)||void 0===e?void 0:e.src},articleMarkdown:'<h1>Murder Mystery Game</h1>\n\n<p>How I wrote a text-based game engine with Webpack, custom loaders, and a generous serving of cryptography.</p>\n\n<p><a href="https://github.com/Kenneth-LJS/Murder-Mystery-Game" target="_blank" rel="noopener noreferrer">GitHub</a> | <a href="/project/victorian-murder-mystery/" target="_blank" rel="noopener noreferrer">Play the Game</a></p>\n\n</header>\n\n## A Victorian Murder Mystery\nDuring my free time, I enjoy helping out with event organising. In 2022, there was an online event with a Victorian Murder Mystery theme. As part of the event, they wanted to include a puzzle game that the attendees could play.\n\nWorking with writers and artists, we put together a simple concept: 6-letter codes would be hidden on the event’s website and in the social media platforms. Observant players could solve the puzzles to get the code, then enter it into the game. Each code would unlock a new chapter of the storyline, with more puzzles to solve to uncover clues that would reveal the murderer.\n\nThe 6-letter codes would be hard to find, and the puzzles would range from trivially easy to challenging. We wanted to encourage players to discuss the solutions, and help each other out with hints along the way. Towards the closing of the event, the last 6-letter code would also be revealed, allowing the players to crack the case.\n\nOne additional note: the game would be hosted on the event website, but after the event, it should also be downloadable and playable offline. This would come into play later.\n\n*Cue ominous music and foreshadowing.*\n\n## The Engine\n\nAs the sole developer of the game engine with only a few weeks to work on this, I had to make this engine simple but powerful. I turned to ol’ reliable: my Webpack boilerplate with React, Typescript, and SCSS.\n\nThe first scene was easy enough: a 6-letter input that would accept valid codes and reject invalid ones.\n\n<p align=center>\n  <video src="./static/code-desktop.mp4" style="width: min(100%, 800px)" preload="auto" muted autoplay loop playsinline data-wf-ignore="true" data-object-fit="cover">\n</p>\n\nI made sure it worked well on mobile devices too.\n\n<p align=center>\n  <video src="./static/code-mobile.mp4" style="width: min(100%, 300px)" preload="auto" muted autoplay loop playsinline data-wf-ignore="true" data-object-fit="cover">\n</p>\n\nThat was the easy part. Once the player has entered a code, we render an interactive chapter. Players needed to choose dialogue options and solve puzzles. I decided the best way to handle this is to store the game data in a JSON format.\n\nEach part of the story would be represented as a node. A `html` node would render HTML.\n\n```json\n{\n    "type": "html",\n    "content": "<p>This is a HTML node!</p><img src=\\"image.png\\">"\n}\n```\n\n\n<p align=center>\n  <img src="./static/html-node.png" style="width: min(100%, 800px)">\n</p>\n\nThe HTML renderer also automatically imports images and maps them to the packaged URL. For example, in the above node, the `image.png` URL is changed to `/ab9d827f80c52ae2d928.png`, since Webpack packages files with a custom name with a hash.\n\nDialogue options would be represented with an `options` node. When the engine reached an `options` node, it would render it and wait for the player’s input. Based on their options, it would choose the next node to jump to.\n\n<p align=center>\n  <video src="./static/options.mp4" style="width: min(100%, 400px)" preload="auto" muted autoplay loop playsinline data-wf-ignore="true" data-object-fit="cover">\n</p>\n\nThis functionality created a lot of complexity for the engine. There were 2 features I wanted. FIrst, I wanted players to be able to backtrack through the dialogue options. If they reached a dead end, they should be able to scroll back to a previous option to select it.\n\n<p align=center>\n  <video src="./static/options-backtrack-2.mp4" style="width: min(100%, 800px)" preload="auto" muted autoplay loop playsinline data-wf-ignore="true" data-object-fit="cover">\n</p>\n\nThe second feature was to have an internal state. If we’re able to store flags, we can remove dialogue options that were already selected.\n\nThese two features aren’t trivially compatible. If I only wanted the ability to backtrack, then I can simply keep track of:\n\n1. The history of nodes rendered\n2. The current node that the player is at\n\n<p align=center>\n  <img src="./static/history-backtrack-a1.png" style="width: min(100%, 600px)">\n</p>\n\nIf the player selects an earlier option, then I can slice off the history at that point…\n\n<p align=center>\n  <img src="./static/history-backtrack-a2.png" style="width: min(100%, 600px)">\n</p>\n\n…then follow the new option.\n\n<p align=center>\n  <img src="./static/history-backtrack-a3.png" style="width: min(100%, 600px)">\n</p>\n\nIf I only wanted the ability to have an internal state, then I will need to keep track of:\n\n1. The history of nodes rendered\n2. The current node that the player is at\n3. A global state\n\nFor example, consider a game tree that looks like this:\n\n<p align=center>\n  <img src="./static/history-backtrack-b1.png" style="width: min(100%, 600px)">\n</p>\n\nA player starts the game and reaches node 2.\n\n<p align=center>\n  <img src="./static/history-backtrack-b2.png" style="width: min(100%, 600px)">\n</p>\n\nThey select choice 1.\n\n<p align=center>\n  <img src="./static/history-backtrack-b3.png" style="width: min(100%, 600px)">\n</p>\n\nFlag 1 is set, and they reach the 4th node where it displays a message based on the flag.\n\n<p align=center>\n  <img src="./static/history-backtrack-b4.png" style="width: min(100%, 600px)">\n</p>\n\nLet’s say we want both features, meaning we want players to be able to backtrack while keeping an internal state. Let’s see what happens when a player tries to set a flag and backtracks. They step through nodes 1 to 3…\n\n<p align=center>\n  <img src="./static/history-backtrack-b3.png" style="width: min(100%, 600px)">\n</p>\n\n…but then decides they’d like to go back and pick choice 2 instead.\n\n<p align=center>\n  <img src="./static/history-backtrack-c4.png" style="width: min(100%, 600px)">\n</p>\n\nFlag 2 is set.\n\n<p align=center>\n  <img src="./static/history-backtrack-c5.png" style="width: min(100%, 600px)">\n</p>\n\nThis time, when they reach the 4th node, both flag 1 and 2 are set, which is supposed to be an invalid state!\n\n<p align=center>\n  <img src="./static/history-backtrack-c6.png" style="width: min(100%, 600px)">\n</p>\n\nThankfully, there is a solution. While keeping track of the nodes, I also keep track of the player state at that particular node.\n\n<p align=center>\n  <img src="./static/history-backtrack-d1.png" style="width: min(100%, 600px)">\n</p>\n\nThe player picks choice 1…\n\n<p align=center>\n  <img src="./static/history-backtrack-d2.png" style="width: min(100%, 600px)">\n</p>\n\n…goes back…\n\n<p align=center>\n  <img src="./static/history-backtrack-d3.png" style="width: min(100%, 600px)">\n</p>\n\n…and picks choice 2.\n\n<p align=center>\n  <img src="./static/history-backtrack-d4.png" style="width: min(100%, 600px)">\n</p>\n\nThis time, there isn’t an issue because only flag 2 is set. Problem solved!\n\n<p align=center>\n  <img src="./static/history-backtrack-d5.png" style="width: min(100%, 600px)">\n</p>\n\nFrom there, I added more node types. There’s a text input node that allows story branching by comparing the input with a string or regex.\n\n```json\n{\n    "type": "text-input",\n    "prompt": "Enter the password",\n    "responses": [\n        {\n            "check": {\n                "type": "string",\n                "string": "PassWord",\n                "isCaseSensitive": true\n            },\n            "action": {\n                "type": "goto",\n                "goto": "success-node"\n            }\n        },\n        {\n            "check": {\n                "type": "regex",\n                "regex": "^password$",\n                "regexFlags": "i"\n            },\n            "action": {\n                "type": "message",\n                "message": "You are close, but the password is case sensitive."\n            }\n        }\n    ],\n    "fallthroughResponse": "Incorrect."\n}\n```\n\n<p align=center>\n  <video src="./static/text-node.mp4" style="width: min(100%, 800px)" preload="auto" muted autoplay loop playsinline data-wf-ignore="true" data-object-fit="cover">\n</p>\n\nThere’s also an image node that allows users to click on various parts of the image to choose an option. First, we need a map of where the clickable areas are.\n\n<p align=center>\n  <img src="./static/click-image-node-map.png" style="width: min(100%, 500px); border: 1px solid white;">\n</p>\n\nAfter that, we specify the actions to perform when the player clicks on each colour.\n\n```json\n{\n    "type": "click-image-input",\n    "prompt": "Click to investigate",\n    "image": "image.png",\n    "clickMap": "image-click-map.png",\n    "clickActions": {\n        "#00ff00": {\n            "type": "goto",\n            "goto": "click-dragon"\n        },\n        "#0000ff": {\n            "type": "goto",\n            "goto": "click-dragon"\n        },\n        "#ffff00": {\n            "type": "goto",\n            "goto": "click-backpack"\n        },\n        "#ff0000": {\n            "type": "message",\n            "message": "“Hey, sweety!”"\n        },\n        "#00ffff": {\n            "type": "message",\n            "message": "!"\n        }\n    },\n    "fallthroughResponse": "Nothing here…"\n}\n```\n\n<p align=center>\n  <video src="./static/click-image-node.mp4" style="width: min(100%, 800px)" preload="auto" muted autoplay loop playsinline data-wf-ignore="true" data-object-fit="cover">\n</p>\n\nAnd a penalty node to discourage players from brute-forcing the answer.\n\n```json\n{\n    "type": "penalty-kick-to-start",\n    "delay": 5000,\n    "content": "Incorrect."\n}\n```\n\n<p align=center>\n  <video src="./static/penalty-node.mp4" style="width: min(100%, 800px)" preload="auto" muted autoplay loop playsinline data-wf-ignore="true" data-object-fit="cover">\n</p>\n\nNow, we can code the story in the JSON format and we’re good to go! Or are we?\n\n## A Gaping Flaw\n\nRemember when I said we needed the game to be playable offline? That meant that we couldn’t rely on a server to check if the 6-letter codes were valid. All the information had to be stored on the frontend: codes, storyline, and all.\n\nThat meant if a tech-savvy player dug around in the source, they would quickly find all the 6-letter codes as well as the entire storyline. If they wanted to, they could also spoil the ending even before we released the final chapter. Not cool.\n\nThankfully, my inner nerd came to the rescue. Over the years, I’ve dug into cryptography concepts and familiarised myself with concepts such as encryption and digital signatures. This would be helpful.\n\n### A Naive Solution\n\nThe simple approach would be to serialise every chapter’s JSON into a string and encrypt it with the 6-letter code as the key. All the encrypted strings are then stored in an array.\n\n\n\n<p align=center>\n  <img src="./static/encryption-1.png" style="width: min(100%, 800px)">\n</p>\n\nWhen a user enters the code, the engine would attempt to decrypt all the chapters. If any of the chapters was successfully decrypted, then it meant that it was a valid code and we let the player access it. Otherwise, we reject it.\n\n\n<p align=center>\n  <img src="./static/encryption-2.png" style="width: min(100%, 800px)">\n</p>\n\nIs it secure? Yes. But it’s also very slow. Each chapter can reach lengths of up to 34,000 characters once serialised. It would be very computationally intensive to attempt to decrypt the entire story’s worth of chapters each time the user enters a 6-letter code, even if an incorrect code was entered.\n\nCan we do better?\n\n### A Better Way\n\nIt turns out we don’t need to decrypt the entire string. Instead of only storing the encrypted chapter, we can hash the 6-letter code and prepend it to the start of the encrypted chapter.\n\n\n<p align=center>\n  <img src="./static/encryption-3.png" style="width: min(100%, 800px)">\n</p>\n\nWhen the player enters a code, we hash it and compare it to all the hashed codes. We only need to attempt to decrypt the chapter whose hash matches.\n\n\n<p align=center>\n  <img src="./static/encryption-4.png" style="width: min(100%, 800px)">\n</p>\n\nThis looks good! But now we have one more issue: because the game has to be viewable offline, it needs to also work in a local file context. This means that the browser’s crypto API is not always available. We’ll need to implement an encryption and decryption function ourselves (uh-oh), and ideally keep it simple (double uh-oh). Thankfully, since we aren’t dealing with sensitive data, we can get away with this. Yay!\n\nI implemented a simple hash function to move the bits around:\n\n```typescript\nfunction hash(str: string) {\n    let hash = 0;\n    const strBytes = stringToBytes(str);\n    for (let i = 0; i < strBytes.length; i++) {\n        hash = (hash << 5) - hash + strBytes[i];\n        hash |= 0; // Convert to 32-bit integer\n    }\n    hash ^= 1249284; // Just to mess some bits around\n    return hash;\n}\n```\n\nThe encryption function is an XOR cipher that uses the 6-letter code as the key.\n\n```typescript\nfunction xorBytesWithKey(bytes: number[], keyBytes: number[]) {\n    return bytes.map((byte, i) => byte ^ keyBytes[i % keyBytes.length]);\n}\n```\n\nThis method was inspired by how digital signatures work, where the hash of the document is encrypted with a private key and attached to the original document as the signature. The verifier can compare the hash of the document to the signature decrypted with the public key to ensure that the signature is valid. In our use case, we’re pairing the hash of the passcode (to verify a match) with the original document (encrypted by the passcode). Neither the passcode nor the original document is revealed to a potential attacker.\n\nThe result is an array of encrypted strings with a prepended hash, each one representing a serialised chapter JSON.\n\nBut does it work?\n\nYes! I sent this to a friend who works in digital security to crack. He pored over the minified code and eventually found the cryptography functions and encrypted strings. When he realised there was no way to cheat the system without knowing the 6-letter codes, he conceded defeat. He did, however, leave me with the following statement: “But you do realise it’s easy for me to brute-force all 6-letter combinations if I wanted to, right?”\n\nFine, you win Jason. But hey, if we wanted the data to be secure, we would be asking for 128-bit keys rather than 6-letter codes (which amount to just above 28 bits). The idea isn’t to make the code uncrackable, it’s to make it more difficult than actually solving the puzzles.\n\nWith that, we’re done with the encryption. Now, whenever we write a chapter, all we have to do is to encrypt it, prepend the hash of its 6-letter code, then add it to the array. Easy, right? Most definitely not!\n\n## Webpack to the Rescue\n\nThe best way to get me to code is to present me with a mind-numbingly banal task, because I’ll write a script to automate the heck out of it.\n\nThankfully, Webpack allows us to write custom loaders. I added a filter to take in JSON files with the `.puzzle.json` extension, and convert it into the encrypted array of strings.\n\n`webpack.config`:\n\n```javascript\nmodule.exports = {\n    ...\n    module: {\n        rules: {\n            ...\n            {\n                test: /\\.puzzle.json$/i,\n                type: \'javascript/auto\',\n                use: [\n                    {\n                        loader: \'json-loader\'\n                    },\n                    {\n                        loader: path.resolve(\'loaders/puzzle-json.js\')\n                    }\n                ]\n            }\n        }\n    }\n}\n```\n\n`loaders/puzzle-json.ts`:\n\n```javascript\nimport { encodeSecretString } from \'../puzzle-crypto\';\n\ntype PuzzleJson = {\n    [passcode: string]: PuzzleData;\n}\n\nfunction puzzleJsonLoader(source: string): string {\n    // `source` is the loaded string of the puzzle JSON file\n    const puzzleJson = JSON.parse(source) as PuzzleJson;\n    const transformedPuzzleJson = transformPuzzleJson(puzzleJson);\n    const transformedSource = JSON.stringify(transformedPuzzleJson);\n    return transformedSource;\n}\n\nfunction transformPuzzleJson(puzzleJson: PuzzleJson): string[] {\n    return Object.keys(puzzleJson).map((passcode) => {\n        const puzzleData = puzzleJson[passcode];\n        return encodeSecretString(passcode, puzzleData);\n    });\n}\n\nmodule.exports = puzzleJsonLoader;\n```\n\nSo the input file may look something like this:\n\n```json\n{ \n    "LITTLE": <story json>\n    "ISLAND": <story json>\n    ...\n}\n```\n\nAnd the encrypted result looks like this:\n\n```JSON\n[\n    "8pJavgF0sHAA0XGCcbEAlHVlhYVgIKCAw...",\n    "EeqguQElEfFQ8WHT0DBQtGU0JAQwALDRY...",\n    ...\n]\n```\n\nAll I have to do is import it in the code as such:\n\n```javascript\nimport Puzzle from \'../data.puzzle.json\';\n```\n\nAnd Webpack does everything for me. It’s a lifesaver during the development process, since I could edit the JSON in development mode, and have it refresh instantly. Easy! \n\n## Case Closed\n\nThe game engine was deployed to the website along with the encrypted story, and the event’s attendees got to cracking the case. By the time the event came to a close, the attendees have solved the murder mystery, and our detectives ride their horse-drawn carriage into the sunset.\n\nAnd while we may enjoy a happy ending, the true treasure was the programming concepts we learnt along the way.\n\nIf you’d like to take a crack at solving this mystery, you can check it out <a href="/project/victorian-murder-mystery/" target="_blank" rel="noopener noreferrer">here</a>! The 6-letter codes are listed below:\n\n- Chapter 1: LISTEN\n- Chapter 2: MINION\n- Chapter 3: SILENT\n- Chapter 4: SENSES\n- Chapter 5: SWORDS\n- Chapter 6: COBWEB\n- Chapter 7: FACADE\n- Chapter 8: NOVELS\n- Chapter 9: TREPID\n- Chapter 10: WHIMSY\n- Chapter 11: ESCAPE\n- Chapter 12: JACKAL\n- Chapter 13: VOODOO\n- Chapter 14: NUANCE\n- Chapter 15: SAFARI\n- Chapter 16: FINALE\n\nHappy cracking!\n'})}},53222:function(e){e.exports={baseFs:"18px",baseColor:"#1f2834",primaryColor:"#eee",secondaryColor:"#11d0da",codeBgColor:"#12171e",article:"page_article__eRMb9"}}},function(e){e.O(0,[757,187,646,774,888,179],function(){return e(e.s=67635)}),_N_E=e.O()}]);