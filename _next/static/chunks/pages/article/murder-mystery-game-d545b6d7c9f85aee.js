(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[399],{67635:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/article/murder-mystery-game",function(){return n(62958)}])},8353:function(e,t,n){"use strict";var a=n(85893),o=n(57779),i=n(55829),r=n(99840),s=n(18532),l=n(98683),h=n(84283),c=n(45146),d=n(53222),p=n.n(d),u=n(15252);let g=h.Ro,y=p().codeBgColor,w=h.Ro['code[class*="language-"]'].fontFamily,m={...g,':not(pre) > code[class*="language-"]':{...g[':not(pre) > code[class*="language-"]'],background:y},'code[class*="language-"]':{...g['code[class*="language-"]'],background:y},'pre[class*="language-"]':{...g['pre[class*="language-"]'],background:y}},f=e=>{let{siteHeadProps:t,articleMarkdown:n}=e;return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.Z,{...t}),(0,a.jsx)(o.Z,{footerContent:"Designed and built from scratch by ".concat(u.Rh," with NextJS and SCSS!"),children:(0,a.jsx)(i.Z,{children:(0,a.jsx)("div",{className:p().article,style:{"--code-font-family":w},children:(0,a.jsx)(s.D,{rehypePlugins:[c.Z],components:{code(e){let{node:t,inline:n,className:o,children:i,...r}=e,s=/language-(\w+)/.exec(o||"");return!n&&s?(0,a.jsx)(l.Z,{style:m,language:s[1],PreTag:"div",...r,children:String(i).replace(/\n$/,"")}):(0,a.jsx)("code",{className:o,...r,children:i})}},children:n})})})})]})};t.Z=f},55731:function(e,t,n){"use strict";n.d(t,{w:function(){return i}});var a=n(15252);function o(e){return new URL(e,a.Tu).toString()}let i={INTRODUCTION_TO_DOMSI:{title:"Introduction to Domsi",href:"/article/introduction-to-domsi/",sitePreview:{img:{src:o("/article/introduction-to-domsi/thumbnail.png"),type:"image/png",width:600,height:400},description:"A powerful and blazingly fast web scraping library that integrates element styles, attributes, and DOM hierarchy in its selectors."},card:{title:"Domsi",description:"A powerful and blazingly fast web scraping library that integrates element styles, attributes, and DOM hierarchy in its selectors.",thumbnailSrc:"/article/introduction-to-domsi/thumbnail.webp",tags:["Web scraping","Typescript","Open Source","Algorithm"]}},MURDER_MYSTERY_GAME:{title:"Murder Mystery Game",href:"/article/murder-mystery-game/",sitePreview:{img:{src:o("/article/murder-mystery-game/thumbnail.png"),type:"image/png",width:600,height:400},description:"The game engine for a Victorian Murder Mystery game I designed for an online event."},card:{title:"Murder Mystery Game",thumbnailSrc:"/article/murder-mystery-game/thumbnail.webp",description:"I created a game engine for a Murder Mystery event! Learn how I used encryption concepts to obfuscate game data from prying players.",tags:["Game Engine","React","SCSS","Typescript","Cryptography","Webpack Loader"]}},FOCUS_SHEPHERD:{title:"Focus Shepherd",href:"/article/focus-shepherd/",sitePreview:{description:"Focus Shepherd is a TamperMonkey / GreaseMonkey script that gently reminds you to focus when you get distracted on your web browser!",img:{src:o("/article/focus-shepherd/thumbnail.png"),type:"image/png",width:600,height:400}},card:{title:"Focus Shepherd",thumbnailSrc:"/article/focus-shepherd/thumbnail.webp",description:"Focus Shepherd is a TamperMonkey / GreaseMonkey script that gently reminds you to focus when you get distracted on your web browser!",tags:["TamperMonkey / GreaseMonkey","HTML","Javascript","Productivity"]}},EXPLORING_EPICYCLES:{title:"Exploring Epicycles",href:"/article/exploring-epicycles/",sitePreview:{description:"Come with me on the journey to explore the Fourier transform, and how we can use that to compute epicycles.",img:{src:o("/article/exploring-epicycles/thumbnail.png"),type:"image/png",width:600,height:400}},card:{title:"Epicycles",thumbnailSrc:"/article/exploring-epicycles/thumbnail.webp",description:"Image processing with the Fast Fourier Transform to create an animated illustration of epicycles.",tags:["Python","Mathematics","Numpy","Python Imaging Library (PILLOW)","FFMPEG"]}},SNAP_CONSOLE:{title:"Snap Console",href:"/article/snap-console/",sitePreview:{img:{src:o("/article/snap-console/thumbnail.png"),type:"image/png",width:600,height:400},description:"A easy-to-use console library in Python to display beautiful outputs."},card:{title:"Snap Console",thumbnailSrc:"/article/snap-console/thumbnail.webp",description:"A easy-to-use console library in Python to display beautiful outputs. Implemented with the curses library.",tags:["Open Source","Python","Curses Terminal Library"]}},SHARD_GAME_ENGINE:{title:"Shard Game Engine",href:"/article/shard-game-engine/",sitePreview:{img:{src:o("/article/shard-game-engine/thumbnail.png"),type:"image/png",width:600,height:400},description:"A text-based game engine with a unique story structure. The engine allows users to create custom stories too."},card:{title:"Shard Game Engine",thumbnailSrc:"/article/shard-game-engine/thumbnail.webp",description:"A text-based game engine with a unique story structure. The engine allows users to create custom stories too.",tags:["Game Engine","SCSS","Typescript","Parcel.js"]}}}},62958:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return s}});var a=n(85893),o=n(8353),i=n(55731);let r=i.w.MURDER_MYSTERY_GAME;function s(){var e;return(0,a.jsx)(o.Z,{siteHeadProps:{title:r.title,description:r.sitePreview.description,image:r.sitePreview.img,twitterImageSrc:null===(e=r.sitePreview.img)||void 0===e?void 0:e.src},articleMarkdown:'<header>\n<h1>Murder Mystery Game</h1>\n\n<p>\n  How I wrote a text-based game engine with Webpack, custom loaders, and a generous serving of cryptography.\n</p>\n\n<p>\n  <a href="#" target="_blank" rel="noopener noreferrer">GitHub</a> | <a href="#" target="_blank" rel="noopener noreferrer">Demo</a>\n</p>\n\n</header>\n\n## A Victorian Murder Mystery\n\nDuring my free time, I enjoy helping out with event organising. In 2022, there was an online event with a Victorian Murder Mystery theme. As part of the event, they wanted to include a puzzle game that the attendees could play.\n\nWorking with writers and artists, we put together a simple concept: 6-letter codes would be hidden on the event’s website and in the social media platforms. Observant players could solve the puzzles to get the code, then enter it into the game. Each code would unlock a new chapter of the storyline, with more puzzles to solve to uncover clues that would reveal the murderer.\n\nThe 6-letter codes would be hard to find, and the puzzles would range from trivially easy to challenging. We wanted to encourage players to discuss the solutions, and help each other out with hints along the way. Towards the closing of the event, the last 6-letter code would also be revealed, allowing the players to crack the case.\n\nOne additional note: the game would be hosted on the event website, but after the event, it should also be downloadable and playable offline. This would come into play later.\n\n*Cue ominous music and foreshadowing*\n\n## The Engine\n\nAs the sole developer of the game engine with only a few weeks to work on this, I had to make this engine simple but powerful. I turned to ol’ reliable: my Webpack boilerplate with React, Typescript, and SCSS.\n\nThe first scene was easy enough: a 6-letter input that would accept valid codes and reject invalid ones.\n\n[Show video of entering invalid codes and valid codes]\n\nI made sure it worked well on mobile devices too.\n\n[Show video of entering invalid codes and valid codes on mobile]\n\nThat was the easy part. Once the player has entered a code, we render an interactive chapter. Players needed to choose dialogue options and solve puzzles. I decided the best way to handle this is to store the game data in a JSON format.\n\nEach part of the story would be represented as a node. A `text` node would render text.\n\n[code of text node]\n\n[image of text node]\n\nAn `image` node would render an image.\n\n[code of image node]\n\n[image of image node]\n\nDialogue options would be represented with an `options` node. When the engine reached an `options` node, it would render it and wait for the player’s input. Based on their options, it would choose the next node to jump to.\n\n[video of clicking an option and scrolling down]\n\nThis functionality created a lot of complexity for the engine. There were 2 features I wanted. FIrst, I wanted players to be able to backtrack through the dialogue options. If they reached a dead end, they should be able to scroll back to a previous option to select it.\n\n[video of choosing the wrong option, scrolling up, then scrolling back down].\n\nThe second feature was to have an internal state. If we’re able to store flags, we can remove dialogue options that were already selected.\n\nThese two features aren’t trivially compatible. If I only wanted the ability to backtrack, then I can simply keep track of:\n\nThe history of nodes rendered\nThe current node that the player is at\n\n[diagram of node history and arrow pointing to the current state]\n\nIf the player selects an earlier option, then I can slice off the history at that point, then continue from there.\n\n[diagram of slicing off the node history at an earlier option, (diagram 1) then branching down to a new path (diagram 2)]\n\nIf I only wanted the ability to have an internal state, then I will need to keep track of:\n\nThe history of nodes rendered\nThe current node that the player is at\nA global state\n\n[diagram of node history, with a box that the current state is on. show how that after selecting an option, we can add a check to the state - split across multiple diagrams]\n\nLet’s say we want both features, meaning we want players to be able to backtrack while keeping an internal state. Let’s see what happens when a player tries to set a flag and backtracks..\n\n[diagram of setting flag 1, then backtrack to an earlier state with flag 1 still set]\n\nIn this sequence, the player enters a state where a flag is set before it’s supposed to have been set. Uh oh!\n\nThankfully, there is a solution. While keeping track of the nodes, I also keep track of the player state at that particular node. Now, we can backtrack without allowing players to reach an invalid state.\n\n[diagram of backtracking while allowing states to work]\n\nFrom there, I added more node types. There’s a text input node that allows story branching by comparing the input with a string or regex.\n\n[code of the text input dialogue]\n\n[video of it in action]\n\nThere’s also an image node that allows users to click on various parts of the image to choose an option.\n\nNow, we can code the story in the JSON format and we’re good to go! Or are we?\n\n## A Gaping Flaw\nRemember when I said we needed the game to be playable offline? That meant that we couldn’t rely on a server to check if the 6-letter codes were valid. All the information had to be stored on the frontend: codes, storyline, and all.\n\nThat meant if a tech-savvy player dug around in the source, they would quickly find all the 6-letter codes as well as the entire storyline. If they wanted to, they could also spoil the ending even before we released the final chapter. Not cool.\n\nThankfully, my inner nerd came to the rescue. Over the years, I’ve dug into cryptography concepts and familiarised myself with concepts such as encryption and digital signatures. This would be helpful.\n\n### A Simple Way\n\nA naive solution would be to serialise every chapter’s JSON into a string and encrypt it with the 6-letter code as the key. When a user enters the code, the engine would attempt to decrypt all the chapters. If any of the chapters was successfully decrypted, then it meant that it was a valid code. Otherwise, we reject it.\n\n[diagram of encryption -> show each chapter being encrypted with a diff key each]\n\n[diagram of decryption -> show a code entered, then unlocking the valid chapter]\n\nIs it secure? Yes. But it’s also very slow. Each chapter can reach lengths of up to [XXX characters]. It would be very computationally intensive to attempt to decrypt the entire story’s worth of chapters each time the user enters a 6-letter code.\n\nCan we do better?\n\n### A Better Way\n\nIt turns out that we don’t need to decrypt the entire string. Let’s assume we have the encrypted chapter as a string. If we hash the 6-letter code and pair it with the encrypted chapter, we only need to compare the hash to ensure that the chapter is a match. Only then do we take the time to decrypt the chapter.\n\nOne more issue is that because the game has to be viewable offline, it needs to also work in a local file context. This means that the browser’s crypto API is not always available. We’ll need to implement an encryption and decryption function ourselves (uh-oh), and ideally keep it simple (double uh-oh). Thankfully, since we aren’t dealing with sensitive data, we can get away with this. Yay1\n\nI implemented a simple [name of hashing and encryption function]. [explain how it all works]\n\nThis method was inspired by how digital signatures work. by pairing [blah blah blah]\n\nThe result is an array of encrypted strings with a prepended hash, each one representing a serialised chapter JSON.\n\nBut does it work?\n\nYup! I sent this to a friend who works in digital security to crack. He pored over the minified code and eventually found the cryptography functions and encrypted strings. When he realised there was no way to cheat the system, he conceded defeat. He did, however, leave me with the following statement: “But you do realise it’s easy for me to brute-force all 6-letter combinations if I wanted to, right?”\n\nFine, you win Jason. But hey, if we wanted the data to be secure, we would be asking for 128-bit keys rather than 6-letter codes (which amount to just above 28 bits). The idea isn’t to make the code uncrackable, it’s to make it more difficult than actually solving the puzzles.\n\nWith that, we’re done with the encryption. Now, whenever we write a chapter, all we have to do is to encrypt it, prepend the hash of its 6-letter code, then add it to the array. Easy, right? Most definitely not!\n\n## Webpack to the Rescue\n\nThe best way to get me to code is to present me with a mind-numbingly banal task, because I’ll write a script to automate the heck out of it.\n\nThankfully, Webpack allows us to write custom loaders. I added a filter to take in JSON files with the `.puzzle.json` extension, and convert it into the encrypted array of strings.\n\n[code of the filter from webpack config]\n\n[code of the custom loader]\n\nSo the input file may look something like this:\n\n```JSON\n{ \n“LITTLE”: <story json>\n“ISLAND”: <story json>\n…\n}\n```\n\nAnd the encrypted result looks like this:\n\n```JSON\n[“ASFASHFLKSFHA”...]\n```\n\nAll I have to do is import it in the code as such:\n\n```javascript\nimport blah blah from “../data.puzzle.json”\n```\n\nAnd Webpack does everything for me. It’s a lifesaver during the development process, since I could edit the JSON in development mode, and have it refresh instantly. Bamm!\n\n## Case Closed\n\nThe game engine was deployed to the website along with the encrypted story, and the event’s attendees got to cracking the case. By the time the event came to a close, the attendees have solved the murder mystery, and our detectives ride their horse-drawn carriage into the sunset.\n\nAnd while we may enjoy a happy ending, the true treasure was the programming concepts we learnt along the way.\n'})}},53222:function(e){e.exports={baseFs:"18px",baseColor:"#1f2834",primaryColor:"#eee",secondaryColor:"#11d0da",codeBgColor:"#12171e",article:"page_article__eRMb9"}}},function(e){e.O(0,[108,187,646,774,888,179],function(){return e(e.s=67635)}),_N_E=e.O()}]);